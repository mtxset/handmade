things unclear:
wchar_t/L"string" purpose
switch vs callbacks (virtuals)

latests controls:
F2 to start and end recording
F6 or alt+F4 quits the game
Enter will spawn player
WASD, arrows moves him
Space - jumps

day 115: simd basics
 1. single instruction multiple data
 2. "normal" b = a + a; -> add b a,a or mov b, a; add b, a;
 3. simd 4-wide
  b0   a0   a0 // lane
  b1 = a1 + a1
  b2   a2   a2
  b3   a3   a3
  -- single operation --
  sse    - 4 wide
  avx    - 8 wide 
  avx512 - 16 wide

        "soa"          vs             "aos"
 structure of arrays            array of structures
 we need: 					struct color {f32 r,g,b,a}
 struct colors {
  f32 r[1000];
  f32 g[1000];
  f32 b[1000];
  f32 a[1000];
 }   

 because intel cpu has a wait to pack data to registers is much manner               

day 111: how to optimize:
 1. gather stats/info - where/how is it slow? (how much they are being run in code?)
 2. estimate how fast should it run
 3. analyze efficiency (algo) and perfromance (code/hardware optimizations)
  3.1 improve algo by removing pieces (removing unnecessary work)
 4. think, solve, code

day 112:
 simd - single instruction multiple data (typical 4 things, but as many 8 or 16 or even 64)
 intrusctions (L0)                       cache            memory
 add register0, register1, register2 	L1, L2, L3	   storing values
 each each is slower than the other (L0 being fastest, L3 being slowest)
 L1 - let's say 2 to read/write?
 L2 - let's say 16 to read/write?
 memory - 300 cycles to read/write?
 add - 2 cycles
 cycle - cpu work - so 3.2 ghz -> max 3.2 * 10^9 cycles per second
 Instruction Cache (our asm code) -> decoded to microcodes -> 1 cycle -> hardware? (???)
 bandwith - gb/s - speed at which we can get our memory (ram->cache->l1,l2,l3...)
 latency - how long it will take for our memory to get upon request
 cache miss - is when an operation before finishing has to grab some memory thus adding latency
 prefetch - guessing what data we need so cpu can start calculation and query memory at the same time
 hyperthreading - if cpu thread is waiting for a memory it switches to other thread
 latency bubbles - cpu waiting for memory 

day 109: 
 resolution independent rendering

day103:
 working on lightning
 3 - layers of reflection - sky, middle, ground (sky and ground kinda done)
 middle will probably have only lightning
 
day93:
 bilinear texture filtering:
 sub pixel drawing: taking samples from 4 closest pixels and blending between them

day90-91:
 coordination explanation
 basis translation: new_vector = new_origin + a_x * new_y_axis + a_y * new_y_axis
 to rotate by (a):
 basis: {
	v3 origin;
	v3 x_axis = cos(a),sin(a)
    v3 y_axis = cos(a+90),sin(a+90) = -sin(a),cos(a) = perpendicular(x_axis)
 }

day87:
- seamless ground textures

day84: 
- ground

day77:
- some sort of stairs/ramp

day66:
- added simualtion regions
- added sword projectile

day60:
- added hitpoints
- color is now v4